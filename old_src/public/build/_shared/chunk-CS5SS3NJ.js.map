{
  "version": 3,
  "sources": ["empty-module:~/data/post.server", "../../../node_modules/.pnpm/remix-typedjson@0.1.7_@remix-run+react@1.19.0_@remix-run+server-runtime@1.19.0_react@18.2.0/node_modules/remix-typedjson/dist/esm/typedjson.js", "../../../node_modules/.pnpm/remix-typedjson@0.1.7_@remix-run+react@1.19.0_@remix-run+server-runtime@1.19.0_react@18.2.0/node_modules/remix-typedjson/dist/esm/remix.js"],
  "sourcesContent": ["module.exports = {};", "function serialize(data) {\n    if (data === null)\n        return { json: 'null' };\n    if (data === undefined)\n        return { json: undefined };\n    const stack = [];\n    const keys = [''];\n    const meta = new Map();\n    function replacer(key, value) {\n        function unwindStack() {\n            while (stack.length > 0) {\n                const top = stack[stack.length - 1];\n                if (top.iteration < top.count) {\n                    top.iteration++;\n                    return top;\n                }\n                if (top.type === 'object') {\n                    keys.pop();\n                }\n                stack.pop();\n            }\n        }\n        let entry = unwindStack();\n        if (entry) {\n            value = entry.value[key];\n        }\n        let metaKey = `${keys[keys.length - 1]}${key}`;\n        const valueType = typeof value;\n        if (valueType === 'object' && value !== null) {\n            let count = 0;\n            let t = 'undefined';\n            if (value instanceof Date) {\n                t = 'date';\n                value = value.toISOString();\n            }\n            else if (value instanceof Set) {\n                value = Array.from(value);\n                count = value.length;\n                t = 'set';\n            }\n            else if (value instanceof Map) {\n                value = Object.fromEntries(value);\n                count = Object.keys(value).length;\n                t = 'map';\n            }\n            else if (value instanceof Array) {\n                t = 'object';\n                count = value.length;\n            }\n            else if (value instanceof RegExp) {\n                t = 'regexp';\n                value = String(value);\n            }\n            else if (value instanceof Error) {\n                t = 'error';\n                value = { name: value.name, message: value.message, stack: value.stack };\n                // push error value to stack\n                stack.push({ type: 'object', value, count: 3, iteration: 0 });\n            }\n            else {\n                count = Object.keys(value).length;\n                t = 'object';\n            }\n            if (t !== 'object') {\n                meta.set(metaKey, t);\n            }\n            if (count !== 0) {\n                stack.push({ type: t, value, count, iteration: 0 });\n                if (key && t === 'object') {\n                    keys.push(`${metaKey}.`);\n                }\n                return value;\n            }\n        }\n        // handle non-object types\n        if (valueType === 'bigint') {\n            meta.set(metaKey, 'bigint');\n            return String(value);\n        }\n        if (valueType === 'number') {\n            if (value === Number.POSITIVE_INFINITY) {\n                meta.set(metaKey, 'infinity');\n                return 'Infinity';\n            }\n            if (value === Number.NEGATIVE_INFINITY) {\n                meta.set(metaKey, '-infinity');\n                return '-Infinity';\n            }\n            if (Number.isNaN(value)) {\n                meta.set(metaKey, 'nan');\n                return 'NaN';\n            }\n        }\n        if (typeof value === 'undefined') {\n            meta.set(metaKey, 'undefined');\n            return null;\n        }\n        return value;\n    }\n    const json = JSON.stringify(data, replacer);\n    return {\n        json,\n        meta: meta.size === 0 ? undefined : Object.fromEntries(meta.entries()),\n    };\n}\nfunction deserialize({ json, meta }) {\n    if (typeof json === 'undefined') {\n        return undefined;\n    }\n    if (!json)\n        return null;\n    const result = JSON.parse(json);\n    if (meta) {\n        applyMeta(result, meta);\n    }\n    return result;\n}\nfunction applyMeta(data, meta) {\n    for (const key of Object.keys(meta)) {\n        applyConversion(data, key.split('.'), meta[key]);\n    }\n    return data;\n    function applyConversion(data, keys, type, depth = 0) {\n        const key = keys[depth];\n        if (depth < keys.length - 1) {\n            applyConversion(data[key], keys, type, depth + 1);\n            return;\n        }\n        const value = data[key];\n        switch (type) {\n            case 'date':\n                data[key] = new Date(value);\n                break;\n            case 'set':\n                data[key] = new Set(value);\n                break;\n            case 'map':\n                data[key] = new Map(Object.entries(value));\n                break;\n            case 'regexp':\n                const match = /^\\/(.*)\\/([dgimsuy]*)$/.exec(value);\n                if (match) {\n                    data[key] = new RegExp(match[1], match[2]);\n                }\n                else {\n                    throw new Error(`Invalid regexp: ${value}`);\n                }\n                break;\n            case 'bigint':\n                data[key] = BigInt(value);\n                break;\n            case 'undefined':\n                data[key] = undefined;\n                break;\n            case 'infinity':\n                data[key] = Number.POSITIVE_INFINITY;\n                break;\n            case '-infinity':\n                data[key] = Number.NEGATIVE_INFINITY;\n                break;\n            case 'nan':\n                data[key] = NaN;\n                break;\n            case 'error':\n                const err = new Error(value.message);\n                err.name = value.name;\n                err.stack = value.stack;\n                data[key] = err;\n                break;\n        }\n    }\n}\nfunction stringify(data, replacer, space) {\n    if (replacer || space) {\n        const { json, meta } = serialize(data);\n        const jsonObj = deserialize({ json });\n        return JSON.stringify({\n            json: jsonObj,\n            meta,\n        }, replacer, space);\n    }\n    return JSON.stringify(serialize(data));\n}\nfunction parse(json) {\n    const result = JSON.parse(json);\n    return result ? deserialize(result) : null;\n}\nconst typedjson = {\n    serialize,\n    stringify,\n    deserialize,\n    parse,\n    applyMeta,\n};\nexport { serialize, deserialize, stringify, parse, applyMeta };\nexport default typedjson;\n", "import { useActionData, useFetcher, useLoaderData, useMatches, } from '@remix-run/react';\nimport * as _typedjson from './typedjson';\nexport const typedjson = (data, init = {}) => {\n    let responseInit = typeof init === 'number' ? { status: init } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has('Content-Type')) {\n        headers.set('Content-Type', 'application/json; charset=utf-8');\n    }\n    return new Response(stringifyRemix(data), {\n        ...responseInit,\n        headers,\n    });\n};\nexport function useTypedLoaderData() {\n    const data = useLoaderData();\n    return deserializeRemix(data);\n}\nexport function useTypedActionData() {\n    const data = useActionData();\n    return deserializeRemix(data);\n}\nexport function useTypedFetcher() {\n    const fetcher = useFetcher();\n    if (fetcher.data) {\n        const newData = deserializeRemix(fetcher.data);\n        fetcher.data = newData ?? undefined;\n    }\n    return fetcher;\n}\nexport function useTypedRouteLoaderData(id) {\n    const match = useMatches().find(match => match.id === id);\n    if (!match)\n        return undefined;\n    return deserializeRemix(match.data);\n}\nexport function stringifyRemix(data) {\n    // prevent double JSON stringification\n    let { json, meta } = _typedjson.serialize(data);\n    if (json && meta) {\n        if (json.startsWith('{')) {\n            json = `${json.substring(0, json.length - 1)},\\\"__meta__\\\":${JSON.stringify(meta)}}`;\n        }\n        else if (json.startsWith('[')) {\n            json = `{\"__obj__\":${json},\"__meta__\":${JSON.stringify(meta)}}`;\n        }\n    }\n    return json;\n}\nexport function deserializeRemix(data) {\n    if (!data)\n        return data;\n    if (data.__obj__) {\n        // handle arrays wrapped in an object\n        return data.__meta__\n            ? _typedjson.applyMeta(data.__obj__, data.__meta__)\n            : data.__obj__;\n    }\n    else if (data.__meta__) {\n        // handle object with __meta__ key\n        // remove before applying meta\n        const meta = data.__meta__;\n        delete data.__meta__;\n        return _typedjson.applyMeta(data, meta);\n    }\n    return data;\n}\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n *\n * @see https://remix.run/api/remix#redirect\n */\nexport const redirect = (url, init = 302) => {\n    let responseInit = init;\n    if (typeof responseInit === 'number') {\n        responseInit = { status: responseInit };\n    }\n    else if (typeof responseInit.status === 'undefined') {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set('Location', url);\n    return new Response(null, {\n        ...responseInit,\n        headers,\n    });\n};\n"],
  "mappings": ";;;;;;;;AAAA;AAAA;AAAA,WAAO,UAAU,CAAC;AAAA;AAAA;;;ACqHlB,SAAS,UAAU,MAAM,MAAM;AAC3B,aAAW,OAAO,OAAO,KAAK,IAAI,GAAG;AACjC,oBAAgB,MAAM,IAAI,MAAM,GAAG,GAAG,KAAK,GAAG,CAAC;AAAA,EACnD;AACA,SAAO;AACP,WAAS,gBAAgBA,OAAM,MAAM,MAAM,QAAQ,GAAG;AAClD,UAAM,MAAM,KAAK,KAAK;AACtB,QAAI,QAAQ,KAAK,SAAS,GAAG;AACzB,sBAAgBA,MAAK,GAAG,GAAG,MAAM,MAAM,QAAQ,CAAC;AAChD;AAAA,IACJ;AACA,UAAM,QAAQA,MAAK,GAAG;AACtB,YAAQ,MAAM;AAAA,MACV,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,IAAI,KAAK,KAAK;AAC1B;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,IAAI,IAAI,KAAK;AACzB;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,IAAI,IAAI,OAAO,QAAQ,KAAK,CAAC;AACzC;AAAA,MACJ,KAAK;AACD,cAAM,QAAQ,yBAAyB,KAAK,KAAK;AACjD,YAAI,OAAO;AACP,UAAAA,MAAK,GAAG,IAAI,IAAI,OAAO,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;AAAA,QAC7C,OACK;AACD,gBAAM,IAAI,MAAM,mBAAmB,OAAO;AAAA,QAC9C;AACA;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,OAAO,KAAK;AACxB;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI;AACZ;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,OAAO;AACnB;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI,OAAO;AACnB;AAAA,MACJ,KAAK;AACD,QAAAA,MAAK,GAAG,IAAI;AACZ;AAAA,MACJ,KAAK;AACD,cAAM,MAAM,IAAI,MAAM,MAAM,OAAO;AACnC,YAAI,OAAO,MAAM;AACjB,YAAI,QAAQ,MAAM;AAClB,QAAAA,MAAK,GAAG,IAAI;AACZ;AAAA,IACR;AAAA,EACJ;AACJ;;;AC9JO,SAAS,qBAAqB;AACjC,QAAM,OAAO,cAAc;AAC3B,SAAO,iBAAiB,IAAI;AAChC;AAgCO,SAAS,iBAAiB,MAAM;AACnC,MAAI,CAAC;AACD,WAAO;AACX,MAAI,KAAK,SAAS;AAEd,WAAO,KAAK,WACK,UAAU,KAAK,SAAS,KAAK,QAAQ,IAChD,KAAK;AAAA,EACf,WACS,KAAK,UAAU;AAGpB,UAAM,OAAO,KAAK;AAClB,WAAO,KAAK;AACZ,WAAkB,UAAU,MAAM,IAAI;AAAA,EAC1C;AACA,SAAO;AACX;",
  "names": ["data"]
}
